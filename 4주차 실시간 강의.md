# 유효성 검사는 어디서 하는것이 좋은가?
    유효성 클래스는 별도로 만들지 말고, 가능하면 생성자에서 검증하도록 해라

# 리팩토링은 어떻게 해나가는게 좋은가?
    가능하면 생성자를 추가하여 생성자에서 생성자를 호출하는 형태로 리팩토링 함으로써 수정해야 하는 코드량을 줄이는 것이 베스트

# immutable vs mutable
    프로그램의 안정성을 생각한다면 상태값을 가지는 객체를 불변객체로 만드는 것이 좋다
    모든 클래스를 상태 변경이 불가능한 불변 클래스로 구현하면 유지보수하기 훨씬 쉬워진다.
    가변 객체의 사용을 엄격하게 금지한다.

    처음에는 무조건 불변객체로 구현하자!!!

    식별자 가변성 문제 x
    null 참조를 없앨 수 있다.
    부수효과를 제거할 수 있다.
    스레드 안전한 코드를 구현할 수 있다.
    더 작고 더 단순한 객체를 만들 수 있다.

    여기서 궁금증! 그럼 그만큼 많은 객체가 만들어진다는 것인데 이건 너무 비효율적인 것 아닌가?
    -> 캐싱을 이용하면 30만개의 객체를 단 45개로 줄일 수 있다.
    isEqualTo는 값만을 비교하지만 isSameAs는 실제 주소를 비교함
    -> 보통 캐싱은 키-밸류 구조로 이루어져 있음(Map을 사용!)

# 움직이는 자동차의 바뀌를 갈아뀔 수 있는 역량
    유지보수 역량!!

    하드웨어 있던 사람들이 소프트웨어로 넘어오면 힘든 이유
    -> 소프트웨어는 기존의 레거시 코드가 있는 상황에서 서비스를 하면서, 기존의 기능을 유지하며 유지보수 해야함
    -> 이러한 역량을 쌓으려면 기존 레거시 코드를 안정적으로 점진적으로 리팩토링 하는 경험을 해보아야 함

# 점진적 리팩토링 전략
    1단계 : AS-IS에 TO-BE 코드를 추가한다
    2단계 : AS-IS에 의존하는 모든 코드를 TO-BE 코드를 사용하도록 점진적으로 리팩토링한다.
    3단계 : 의존하는 모든 코드가 TO-BE 코드를 사용하면 AS-IS 코드를 삭제한다.

# 인터페이스 분리
    인터페이스를 분리할 때는 명확한 이유가 있어야한다.
    벌어지지 않은 일을 미리 예상하고 인터페이스를 분리하지 마라.
    필요한 시점에 빠르게 인터페이스를 분리할 수 있어야 한다.

    서비스를 유지보수 하다보면 변화가 지속적으로 발생하는 부분과
    변화가 발생하지 않는 부분을 분리하는 감각이 필요하다.

    변화가 지속적으로 발생하는 부분은 인터페이스 + 구현 클래스
    변화가 발생하지 않는 부분은 only 구현 클래스
    
    1. 유지보수하기 쉽고, 테스트 하기 쉬운 코드가 된다면 인터페이스를 분리하자
    2. 요구사항이 자주 변경되는 부분은 인터페이스를 분리하자
